===================================================================
--- a/daemon/gdm-session.c
+++ a/daemon/gdm-session.c
@@ -911,73 +911,73 @@ static void
 worker_on_saved_language_name_read (GdmDBusWorker          *worker,
                                     const char             *language_name,
                                     GdmSessionConversation *conversation)
 {
         GdmSession *self = conversation->session;
 
         if (strlen (language_name) > 0 &&
             strcmp (language_name, get_default_language_name (self)) != 0) {
                 g_free (self->priv->saved_language);
                 self->priv->saved_language = g_strdup (language_name);
 
                 if (self->priv->greeter_interface != NULL) {
                         gdm_dbus_greeter_emit_default_language_name_changed (self->priv->greeter_interface,
                                                                              language_name);
                 }
         }
 }
 
 static void
 worker_on_saved_session_name_read (GdmDBusWorker          *worker,
                                    const char             *session_name,
                                    GdmSessionConversation *conversation)
 {
         GdmSession *self = conversation->session;
 
         if (! get_session_command_for_name (self, session_name, NULL)) {
                 /* ignore sessions that don't exist */
                 g_debug ("GdmSession: not using invalid .dmrc session: %s", session_name);
                 g_free (self->priv->saved_session);
                 self->priv->saved_session = NULL;
-                return;
-        }
-
-        if (strcmp (session_name,
-                    get_default_session_name (self)) != 0) {
+        } else if (strcmp (session_name,
+                   get_default_session_name (self)) != 0) {
                 g_free (self->priv->saved_session);
                 self->priv->saved_session = g_strdup (session_name);
 
                 if (self->priv->greeter_interface != NULL) {
                         gdm_dbus_greeter_emit_default_session_name_changed (self->priv->greeter_interface,
                                                                             session_name);
                 }
         }
+
+        update_session_type (self);
+
 }
 
 static GdmSessionConversation *
 find_conversation_by_pid (GdmSession *self,
                           GPid        pid)
 {
         GHashTableIter iter;
         gpointer key, value;
 
         g_hash_table_iter_init (&iter, self->priv->conversations);
         while (g_hash_table_iter_next (&iter, &key, &value)) {
                 GdmSessionConversation *conversation;
 
                 conversation = (GdmSessionConversation *) value;
 
                 if (conversation->worker_pid == pid) {
                         return conversation;
                 }
         }
 
         return NULL;
 }
 
 static gboolean
 allow_worker_function (GDBusAuthObserver *observer,
                        GIOStream         *stream,
                        GCredentials      *credentials,
                        GdmSession        *self)
 {
         uid_t connecting_user;
@@ -2268,79 +2268,81 @@ send_setup_for_program (GdmSession *self,
         }
 
         g_debug ("GdmSession: Beginning setup for session for program using PAM service %s", service_name);
 
         conversation = find_conversation_by_name (self, service_name);
         if (conversation != NULL) {
                 gdm_dbus_worker_call_setup_for_program (conversation->worker_proxy,
                                                         service_name,
                                                         username,
                                                         display_name,
                                                         display_x11_authority_file,
                                                         display_device,
                                                         display_seat_id,
                                                         display_hostname,
                                                         self->priv->display_is_local,
                                                         self->priv->display_is_initial,
                                                         log_file,
                                                         conversation->worker_cancellable,
                                                         (GAsyncReadyCallback) on_setup_complete_cb,
                                                         conversation);
         }
 }
 
 void
 gdm_session_setup (GdmSession *self,
                    const char *service_name)
 {
 
         g_return_if_fail (GDM_IS_SESSION (self));
 
+        update_session_type (self);
+
         send_setup (self, service_name);
-        gdm_session_defaults_changed (self);
 }
 
 
 void
 gdm_session_setup_for_user (GdmSession *self,
                             const char *service_name,
                             const char *username)
 {
 
         g_return_if_fail (GDM_IS_SESSION (self));
         g_return_if_fail (username != NULL);
 
+        update_session_type (self);
+
         gdm_session_select_user (self, username);
 
         self->priv->is_program_session = FALSE;
         send_setup_for_user (self, service_name);
-        gdm_session_defaults_changed (self);
 }
 
 void
 gdm_session_setup_for_program (GdmSession *self,
                                const char *service_name,
                                const char *username,
                                const char *log_file)
 {
 
         g_return_if_fail (GDM_IS_SESSION (self));
 
         self->priv->is_program_session = TRUE;
         send_setup_for_program (self, service_name, username, log_file);
 }
 
 void
 gdm_session_authenticate (GdmSession *self,
                           const char *service_name)
 {
         GdmSessionConversation *conversation;
 
         g_return_if_fail (GDM_IS_SESSION (self));
 
         conversation = find_conversation_by_name (self, service_name);
         if (conversation != NULL) {
                 gdm_dbus_worker_call_authenticate (conversation->worker_proxy,
                                                    conversation->worker_cancellable,
                                                    (GAsyncReadyCallback) on_authenticate_cb,
                                                    conversation);
         }
